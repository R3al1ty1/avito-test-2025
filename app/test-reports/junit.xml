<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="0" failures="8" skipped="0" tests="9" time="6.157" timestamp="2025-02-16T20:56:52.894038+00:00" hostname="a8fc3dbc62c3"><testcase classname="tests.test_api" name="test_auth_new_user" time="0.388" /><testcase classname="tests.test_api" name="test_auth_existing_user" time="0.005"><failure message="RuntimeError: Task &lt;Task pending name='anyio.from_thread.BlockingPortal._call_func' coro=&lt;BlockingPortal._call_func() running at /usr/local/lib/python3.11/site-packages/anyio/from_thread.py:221&gt; cb=[TaskGroup._spawn.&lt;locals&gt;.task_done() at /usr/local/lib/python3.11/site-packages/anyio/_backends/_asyncio.py:789]&gt; got Future &lt;Future pending cb=[BaseProtocol._on_waiter_completed()]&gt; attached to a different loop">session = &lt;sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff8a4be710&gt;

    async def test_auth_existing_user(session: AsyncSession):
        # Сначала создаем пользователя
&gt;       client.post("/api/auth", json=TEST_USER)

tests/test_api.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/starlette/testclient.py:531: in post
    return super().post(
/usr/local/lib/python3.11/site-packages/httpx/_client.py:1144: in post
    return self.request(
/usr/local/lib/python3.11/site-packages/starlette/testclient.py:430: in request
    return super().request(
/usr/local/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
/usr/local/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/usr/local/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/usr/local/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
/usr/local/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
/usr/local/lib/python3.11/site-packages/starlette/testclient.py:339: in handle_request
    raise exc
/usr/local/lib/python3.11/site-packages/starlette/testclient.py:336: in handle_request
    portal.call(self.app, scope, receive, send)
/usr/local/lib/python3.11/site-packages/anyio/from_thread.py:290: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
/usr/local/lib/python3.11/concurrent/futures/_base.py:456: in result
    return self.__get_result()
/usr/local/lib/python3.11/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
/usr/local/lib/python3.11/site-packages/anyio/from_thread.py:221: in _call_func
    retval = await retval_or_awaitable
/usr/local/lib/python3.11/site-packages/fastapi/applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/middleware/errors.py:187: in __call__
    raise exc
/usr/local/lib/python3.11/site-packages/starlette/middleware/errors.py:165: in __call__
    await self.app(scope, receive, _send)
/usr/local/lib/python3.11/site-packages/starlette/middleware/exceptions.py:62: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
/usr/local/lib/python3.11/site-packages/starlette/routing.py:715: in __call__
    await self.middleware_stack(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/routing.py:735: in app
    await route.handle(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/routing.py:288: in handle
    await self.app(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/routing.py:76: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
/usr/local/lib/python3.11/site-packages/starlette/routing.py:73: in app
    response = await f(request)
/usr/local/lib/python3.11/site-packages/fastapi/routing.py:301: in app
    raw_response = await run_endpoint_function(
/usr/local/lib/python3.11/site-packages/fastapi/routing.py:212: in run_endpoint_function
    return await dependant.call(**values)
api/api_v1/users.py:39: in auth
    result = await db.execute(select(User).where(User.username == username))
/usr/local/lib/python3.11/site-packages/sqlalchemy/ext/asyncio/session.py:463: in execute
    result = await greenlet_spawn(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2365: in execute
    return self._execute_internal(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2251: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise exc_info[1].with_traceback(exc_info[2])
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/default.py:942: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:580: in execute
    self._adapt_connection.await_(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:515: in _prepare_and_execute
    await adapt_connection._start_transaction()
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:845: in _start_transaction
    self._handle_exception(error)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:794: in _handle_exception
    raise error
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:843: in _start_transaction
    await self._transaction.start()
/usr/local/lib/python3.11/site-packages/asyncpg/transaction.py:146: in start
    await self._connection.execute(query)
/usr/local/lib/python3.11/site-packages/asyncpg/connection.py:349: in execute
    result = await self._protocol.query(query, timeout)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   RuntimeError: Task &lt;Task pending name='anyio.from_thread.BlockingPortal._call_func' coro=&lt;BlockingPortal._call_func() running at /usr/local/lib/python3.11/site-packages/anyio/from_thread.py:221&gt; cb=[TaskGroup._spawn.&lt;locals&gt;.task_done() at /usr/local/lib/python3.11/site-packages/anyio/_backends/_asyncio.py:789]&gt; got Future &lt;Future pending cb=[BaseProtocol._on_waiter_completed()]&gt; attached to a different loop

asyncpg/protocol/protocol.pyx:375: RuntimeError</failure></testcase><testcase classname="tests.test_api" name="test_auth_validation_errors" time="0.015"><failure message="RuntimeError: Task &lt;Task pending name='anyio.from_thread.BlockingPortal._call_func' coro=&lt;BlockingPortal._call_func() running at /usr/local/lib/python3.11/site-packages/anyio/from_thread.py:221&gt; cb=[TaskGroup._spawn.&lt;locals&gt;.task_done() at /usr/local/lib/python3.11/site-packages/anyio/_backends/_asyncio.py:789]&gt; got Future &lt;Future pending cb=[BaseProtocol._on_waiter_completed()]&gt; attached to a different loop">def test_auth_validation_errors():
        # Пустые данные
        response = client.post("/api/auth", json={"username": "", "password": ""})
        assert response.status_code == status.HTTP_400_BAD_REQUEST
    
        # Неверный пароль
&gt;       response = client.post("/api/auth", json={"username": TEST_USER["username"], "password": "wrong"})

tests/test_api.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/starlette/testclient.py:531: in post
    return super().post(
/usr/local/lib/python3.11/site-packages/httpx/_client.py:1144: in post
    return self.request(
/usr/local/lib/python3.11/site-packages/starlette/testclient.py:430: in request
    return super().request(
/usr/local/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
/usr/local/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/usr/local/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/usr/local/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
/usr/local/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
/usr/local/lib/python3.11/site-packages/starlette/testclient.py:339: in handle_request
    raise exc
/usr/local/lib/python3.11/site-packages/starlette/testclient.py:336: in handle_request
    portal.call(self.app, scope, receive, send)
/usr/local/lib/python3.11/site-packages/anyio/from_thread.py:290: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
/usr/local/lib/python3.11/concurrent/futures/_base.py:456: in result
    return self.__get_result()
/usr/local/lib/python3.11/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
/usr/local/lib/python3.11/site-packages/anyio/from_thread.py:221: in _call_func
    retval = await retval_or_awaitable
/usr/local/lib/python3.11/site-packages/fastapi/applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/middleware/errors.py:187: in __call__
    raise exc
/usr/local/lib/python3.11/site-packages/starlette/middleware/errors.py:165: in __call__
    await self.app(scope, receive, _send)
/usr/local/lib/python3.11/site-packages/starlette/middleware/exceptions.py:62: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
/usr/local/lib/python3.11/site-packages/starlette/routing.py:715: in __call__
    await self.middleware_stack(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/routing.py:735: in app
    await route.handle(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/routing.py:288: in handle
    await self.app(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/routing.py:76: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
/usr/local/lib/python3.11/site-packages/starlette/routing.py:73: in app
    response = await f(request)
/usr/local/lib/python3.11/site-packages/fastapi/routing.py:301: in app
    raw_response = await run_endpoint_function(
/usr/local/lib/python3.11/site-packages/fastapi/routing.py:212: in run_endpoint_function
    return await dependant.call(**values)
api/api_v1/users.py:39: in auth
    result = await db.execute(select(User).where(User.username == username))
/usr/local/lib/python3.11/site-packages/sqlalchemy/ext/asyncio/session.py:463: in execute
    result = await greenlet_spawn(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2365: in execute
    return self._execute_internal(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2251: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise exc_info[1].with_traceback(exc_info[2])
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/default.py:942: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:580: in execute
    self._adapt_connection.await_(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:515: in _prepare_and_execute
    await adapt_connection._start_transaction()
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:845: in _start_transaction
    self._handle_exception(error)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:794: in _handle_exception
    raise error
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:843: in _start_transaction
    await self._transaction.start()
/usr/local/lib/python3.11/site-packages/asyncpg/transaction.py:146: in start
    await self._connection.execute(query)
/usr/local/lib/python3.11/site-packages/asyncpg/connection.py:349: in execute
    result = await self._protocol.query(query, timeout)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   RuntimeError: Task &lt;Task pending name='anyio.from_thread.BlockingPortal._call_func' coro=&lt;BlockingPortal._call_func() running at /usr/local/lib/python3.11/site-packages/anyio/from_thread.py:221&gt; cb=[TaskGroup._spawn.&lt;locals&gt;.task_done() at /usr/local/lib/python3.11/site-packages/anyio/_backends/_asyncio.py:789]&gt; got Future &lt;Future pending cb=[BaseProtocol._on_waiter_completed()]&gt; attached to a different loop

asyncpg/protocol/protocol.pyx:375: RuntimeError</failure></testcase><testcase classname="tests.test_api" name="test_info_endpoint" time="0.003"><failure message="sqlalchemy.exc.InterfaceError: (sqlalchemy.dialects.postgresql.asyncpg.InterfaceError) &lt;class 'asyncpg.exceptions._base.InterfaceError'&gt;: cannot perform operation: another operation is in progress&#10;[SQL: INSERT INTO users (username, password, balance) VALUES ($1::VARCHAR, $2::VARCHAR, $3::INTEGER) RETURNING users.id]&#10;[parameters: ('testuser', 'testpass', 100)]&#10;(Background on this error at: https://sqlalche.me/e/20/rvf5)">self = &lt;AdaptedConnection &lt;asyncpg.connection.Connection object at 0xffff8a4353f0&gt;&gt;

    async def _start_transaction(self):
        if self.isolation_level == "autocommit":
            return
    
        try:
            self._transaction = self._connection.transaction(
                isolation=self.isolation_level,
                readonly=self.readonly,
                deferrable=self.deferrable,
            )
&gt;           await self._transaction.start()

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:843: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/asyncpg/transaction.py:146: in start
    await self._connection.execute(query)
/usr/local/lib/python3.11/site-packages/asyncpg/connection.py:349: in execute
    result = await self._protocol.query(query, timeout)
asyncpg/protocol/protocol.pyx:360: in query
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   asyncpg.exceptions._base.InterfaceError: cannot perform operation: another operation is in progress

asyncpg/protocol/protocol.pyx:745: InterfaceError

The above exception was the direct cause of the following exception:

self = &lt;sqlalchemy.engine.base.Connection object at 0xffff7b66ec90&gt;
dialect = &lt;sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0xffff8b0b0750&gt;
context = &lt;sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0xffff7b66f310&gt;
statement = &lt;sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0xffff8a4a4490&gt;
parameters = [('testuser', 'testpass', 100)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -&gt; CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
&gt;                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/default.py:942: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:580: in execute
    self._adapt_connection.await_(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:515: in _prepare_and_execute
    await adapt_connection._start_transaction()
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:845: in _start_transaction
    self._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;AdaptedConnection &lt;asyncpg.connection.Connection object at 0xffff8a4353f0&gt;&gt;
error = InterfaceError('cannot perform operation: another operation is in progress')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
&gt;                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.InterfaceError: &lt;class 'asyncpg.exceptions._base.InterfaceError'&gt;: cannot perform operation: another operation is in progress

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:792: InterfaceError

The above exception was the direct cause of the following exception:

session = &lt;sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff7b66e110&gt;

    async def test_info_endpoint(session: AsyncSession):
        # Создаем тестовые данные
        user = User(**TEST_USER, balance=100)
        session.add(user)
&gt;       await session.commit()

tests/test_api.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sqlalchemy/ext/asyncio/session.py:1011: in commit
    await greenlet_spawn(self.sync_session.commit)
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
&lt;string&gt;:2: in commit
    ???
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
&lt;string&gt;:2: in _prepare_impl
    ???
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/default.py:942: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:580: in execute
    self._adapt_connection.await_(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:515: in _prepare_and_execute
    await adapt_connection._start_transaction()
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:845: in _start_transaction
    self._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;AdaptedConnection &lt;asyncpg.connection.Connection object at 0xffff8a4353f0&gt;&gt;
error = InterfaceError('cannot perform operation: another operation is in progress')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
&gt;                   raise translated_error from error
E                   sqlalchemy.exc.InterfaceError: (sqlalchemy.dialects.postgresql.asyncpg.InterfaceError) &lt;class 'asyncpg.exceptions._base.InterfaceError'&gt;: cannot perform operation: another operation is in progress
E                   [SQL: INSERT INTO users (username, password, balance) VALUES ($1::VARCHAR, $2::VARCHAR, $3::INTEGER) RETURNING users.id]
E                   [parameters: ('testuser', 'testpass', 100)]
E                   (Background on this error at: https://sqlalche.me/e/20/rvf5)

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:792: InterfaceError</failure></testcase><testcase classname="tests.test_api" name="test_send_coin_success" time="0.005"><failure message="sqlalchemy.exc.InterfaceError: (sqlalchemy.dialects.postgresql.asyncpg.InterfaceError) &lt;class 'asyncpg.exceptions._base.InterfaceError'&gt;: cannot perform operation: another operation is in progress&#10;[SQL: INSERT INTO users (username, password, balance) SELECT p0::VARCHAR, p1::VARCHAR, p2::INTEGER FROM (VALUES ($1::VARCHAR, $2::VARCHAR, $3::INTEGER, 0), ($4::VARCHAR, $5::VARCHAR, $6::INTEGER, 1)) AS imp_sen(p0, p1, p2, sen_counter) ORDER BY sen_counter RETURNING users.id, users.id AS id__1]&#10;[parameters: ('testuser', 'testpass', 100, 'receiver', 'pass', 0)]&#10;(Background on this error at: https://sqlalche.me/e/20/rvf5)">self = &lt;AdaptedConnection &lt;asyncpg.connection.Connection object at 0xffff8ae00400&gt;&gt;

    async def _start_transaction(self):
        if self.isolation_level == "autocommit":
            return
    
        try:
            self._transaction = self._connection.transaction(
                isolation=self.isolation_level,
                readonly=self.readonly,
                deferrable=self.deferrable,
            )
&gt;           await self._transaction.start()

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:843: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/asyncpg/transaction.py:146: in start
    await self._connection.execute(query)
/usr/local/lib/python3.11/site-packages/asyncpg/connection.py:349: in execute
    result = await self._protocol.query(query, timeout)
asyncpg/protocol/protocol.pyx:360: in query
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   asyncpg.exceptions._base.InterfaceError: cannot perform operation: another operation is in progress

asyncpg/protocol/protocol.pyx:745: InterfaceError

The above exception was the direct cause of the following exception:

self = &lt;sqlalchemy.engine.base.Connection object at 0xffff7b0a97d0&gt;
dialect = &lt;sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0xffff8b0b0750&gt;
context = &lt;sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0xffff7b0a9d90&gt;

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -&gt; CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
&gt;                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/default.py:942: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:580: in execute
    self._adapt_connection.await_(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:515: in _prepare_and_execute
    await adapt_connection._start_transaction()
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:845: in _start_transaction
    self._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;AdaptedConnection &lt;asyncpg.connection.Connection object at 0xffff8ae00400&gt;&gt;
error = InterfaceError('cannot perform operation: another operation is in progress')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
&gt;                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.InterfaceError: &lt;class 'asyncpg.exceptions._base.InterfaceError'&gt;: cannot perform operation: another operation is in progress

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:792: InterfaceError

The above exception was the direct cause of the following exception:

session = &lt;sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff7b0a8c10&gt;

    async def test_send_coin_success(session: AsyncSession):
        # Создаем двух пользователей
        sender = User(**TEST_USER, balance=100)
        receiver = User(username="receiver", password="pass", balance=0)
        session.add_all([sender, receiver])
&gt;       await session.commit()

tests/test_api.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sqlalchemy/ext/asyncio/session.py:1011: in commit
    await greenlet_spawn(self.sync_session.commit)
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
&lt;string&gt;:2: in commit
    ???
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
&lt;string&gt;:2: in _prepare_impl
    ???
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1841: in _execute_context
    return self._exec_insertmany_context(dialect, context)
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2123: in _exec_insertmany_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2115: in _exec_insertmany_context
    dialect.do_execute(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/default.py:942: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:580: in execute
    self._adapt_connection.await_(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:515: in _prepare_and_execute
    await adapt_connection._start_transaction()
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:845: in _start_transaction
    self._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;AdaptedConnection &lt;asyncpg.connection.Connection object at 0xffff8ae00400&gt;&gt;
error = InterfaceError('cannot perform operation: another operation is in progress')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
&gt;                   raise translated_error from error
E                   sqlalchemy.exc.InterfaceError: (sqlalchemy.dialects.postgresql.asyncpg.InterfaceError) &lt;class 'asyncpg.exceptions._base.InterfaceError'&gt;: cannot perform operation: another operation is in progress
E                   [SQL: INSERT INTO users (username, password, balance) SELECT p0::VARCHAR, p1::VARCHAR, p2::INTEGER FROM (VALUES ($1::VARCHAR, $2::VARCHAR, $3::INTEGER, 0), ($4::VARCHAR, $5::VARCHAR, $6::INTEGER, 1)) AS imp_sen(p0, p1, p2, sen_counter) ORDER BY sen_counter RETURNING users.id, users.id AS id__1]
E                   [parameters: ('testuser', 'testpass', 100, 'receiver', 'pass', 0)]
E                   (Background on this error at: https://sqlalche.me/e/20/rvf5)

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:792: InterfaceError</failure></testcase><testcase classname="tests.test_api" name="test_send_coin_validation_errors" time="0.004"><failure message="assert 401 == 400&#10; +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code&#10; +  and   400 = status.HTTP_400_BAD_REQUEST">def test_send_coin_validation_errors():
        # Отправка самому себе
        response = client.post(
            "/api/sendCoin",
            json={"to_user": TEST_USER["username"], "amount": 50},
            headers={"Authorization": "Bearer testtoken"}
        )
&gt;       assert response.status_code == status.HTTP_400_BAD_REQUEST
E       assert 401 == 400
E        +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code
E        +  and   400 = status.HTTP_400_BAD_REQUEST

tests/test_api.py:111: AssertionError</failure></testcase><testcase classname="tests.test_api" name="test_buy_item_success" time="0.003"><failure message="sqlalchemy.exc.InterfaceError: (sqlalchemy.dialects.postgresql.asyncpg.InterfaceError) &lt;class 'asyncpg.exceptions._base.InterfaceError'&gt;: cannot perform operation: another operation is in progress&#10;[SQL: INSERT INTO merch_items (name, price) VALUES ($1::VARCHAR, $2::INTEGER) RETURNING merch_items.id]&#10;[parameters: ('sword', 50)]&#10;(Background on this error at: https://sqlalche.me/e/20/rvf5)">self = &lt;AdaptedConnection &lt;asyncpg.connection.Connection object at 0xffff8a4353f0&gt;&gt;

    async def _start_transaction(self):
        if self.isolation_level == "autocommit":
            return
    
        try:
            self._transaction = self._connection.transaction(
                isolation=self.isolation_level,
                readonly=self.readonly,
                deferrable=self.deferrable,
            )
&gt;           await self._transaction.start()

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:843: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/asyncpg/transaction.py:146: in start
    await self._connection.execute(query)
/usr/local/lib/python3.11/site-packages/asyncpg/connection.py:349: in execute
    result = await self._protocol.query(query, timeout)
asyncpg/protocol/protocol.pyx:360: in query
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   asyncpg.exceptions._base.InterfaceError: cannot perform operation: another operation is in progress

asyncpg/protocol/protocol.pyx:745: InterfaceError

The above exception was the direct cause of the following exception:

self = &lt;sqlalchemy.engine.base.Connection object at 0xffff7be4dcd0&gt;
dialect = &lt;sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0xffff8b0b0750&gt;
context = &lt;sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0xffff7be4f650&gt;
statement = &lt;sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0xffff7be4d390&gt;
parameters = [('sword', 50)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -&gt; CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
&gt;                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/default.py:942: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:580: in execute
    self._adapt_connection.await_(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:515: in _prepare_and_execute
    await adapt_connection._start_transaction()
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:845: in _start_transaction
    self._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;AdaptedConnection &lt;asyncpg.connection.Connection object at 0xffff8a4353f0&gt;&gt;
error = InterfaceError('cannot perform operation: another operation is in progress')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
&gt;                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.InterfaceError: &lt;class 'asyncpg.exceptions._base.InterfaceError'&gt;: cannot perform operation: another operation is in progress

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:792: InterfaceError

The above exception was the direct cause of the following exception:

session = &lt;sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff7be4ca90&gt;

    async def test_buy_item_success(session: AsyncSession):
        # Создаем пользователя и товар
        user = User(**TEST_USER, balance=100)
        merch = MerchItem(**TEST_ITEM)
        session.add_all([user, merch])
&gt;       await session.commit()

tests/test_api.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sqlalchemy/ext/asyncio/session.py:1011: in commit
    await greenlet_spawn(self.sync_session.commit)
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
&lt;string&gt;:2: in commit
    ???
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
&lt;string&gt;:2: in _prepare_impl
    ???
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/default.py:942: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:580: in execute
    self._adapt_connection.await_(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:515: in _prepare_and_execute
    await adapt_connection._start_transaction()
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:845: in _start_transaction
    self._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;AdaptedConnection &lt;asyncpg.connection.Connection object at 0xffff8a4353f0&gt;&gt;
error = InterfaceError('cannot perform operation: another operation is in progress')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
&gt;                   raise translated_error from error
E                   sqlalchemy.exc.InterfaceError: (sqlalchemy.dialects.postgresql.asyncpg.InterfaceError) &lt;class 'asyncpg.exceptions._base.InterfaceError'&gt;: cannot perform operation: another operation is in progress
E                   [SQL: INSERT INTO merch_items (name, price) VALUES ($1::VARCHAR, $2::INTEGER) RETURNING merch_items.id]
E                   [parameters: ('sword', 50)]
E                   (Background on this error at: https://sqlalche.me/e/20/rvf5)

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:792: InterfaceError</failure></testcase><testcase classname="tests.test_api" name="test_buy_item_errors" time="0.006"><failure message="sqlalchemy.exc.InterfaceError: (sqlalchemy.dialects.postgresql.asyncpg.InterfaceError) &lt;class 'asyncpg.exceptions._base.InterfaceError'&gt;: cannot perform operation: another operation is in progress&#10;[SQL: INSERT INTO merch_items (name, price) VALUES ($1::VARCHAR, $2::INTEGER) RETURNING merch_items.id]&#10;[parameters: ('sword', 50)]&#10;(Background on this error at: https://sqlalche.me/e/20/rvf5)">self = &lt;AdaptedConnection &lt;asyncpg.connection.Connection object at 0xffff8ae00400&gt;&gt;

    async def _start_transaction(self):
        if self.isolation_level == "autocommit":
            return
    
        try:
            self._transaction = self._connection.transaction(
                isolation=self.isolation_level,
                readonly=self.readonly,
                deferrable=self.deferrable,
            )
&gt;           await self._transaction.start()

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:843: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/asyncpg/transaction.py:146: in start
    await self._connection.execute(query)
/usr/local/lib/python3.11/site-packages/asyncpg/connection.py:349: in execute
    result = await self._protocol.query(query, timeout)
asyncpg/protocol/protocol.pyx:360: in query
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   asyncpg.exceptions._base.InterfaceError: cannot perform operation: another operation is in progress

asyncpg/protocol/protocol.pyx:745: InterfaceError

The above exception was the direct cause of the following exception:

self = &lt;sqlalchemy.engine.base.Connection object at 0xffff7b0c9490&gt;
dialect = &lt;sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0xffff8b0b0750&gt;
context = &lt;sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0xffff7b0c9d50&gt;
statement = &lt;sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0xffff7be4d390&gt;
parameters = [('sword', 50)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -&gt; CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
&gt;                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/default.py:942: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:580: in execute
    self._adapt_connection.await_(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:515: in _prepare_and_execute
    await adapt_connection._start_transaction()
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:845: in _start_transaction
    self._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;AdaptedConnection &lt;asyncpg.connection.Connection object at 0xffff8ae00400&gt;&gt;
error = InterfaceError('cannot perform operation: another operation is in progress')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
&gt;                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.InterfaceError: &lt;class 'asyncpg.exceptions._base.InterfaceError'&gt;: cannot perform operation: another operation is in progress

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:792: InterfaceError

The above exception was the direct cause of the following exception:

session = &lt;sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff7b0c8fd0&gt;

    async def test_buy_item_errors(session: AsyncSession):
        # Недостаточно средств
        user = User(**TEST_USER, balance=10)
        merch = MerchItem(**TEST_ITEM)
        session.add_all([user, merch])
&gt;       await session.commit()

tests/test_api.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sqlalchemy/ext/asyncio/session.py:1011: in commit
    await greenlet_spawn(self.sync_session.commit)
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
&lt;string&gt;:2: in commit
    ???
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
&lt;string&gt;:2: in _prepare_impl
    ???
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/default.py:942: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:580: in execute
    self._adapt_connection.await_(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:515: in _prepare_and_execute
    await adapt_connection._start_transaction()
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:845: in _start_transaction
    self._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;AdaptedConnection &lt;asyncpg.connection.Connection object at 0xffff8ae00400&gt;&gt;
error = InterfaceError('cannot perform operation: another operation is in progress')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
&gt;                   raise translated_error from error
E                   sqlalchemy.exc.InterfaceError: (sqlalchemy.dialects.postgresql.asyncpg.InterfaceError) &lt;class 'asyncpg.exceptions._base.InterfaceError'&gt;: cannot perform operation: another operation is in progress
E                   [SQL: INSERT INTO merch_items (name, price) VALUES ($1::VARCHAR, $2::INTEGER) RETURNING merch_items.id]
E                   [parameters: ('sword', 50)]
E                   (Background on this error at: https://sqlalche.me/e/20/rvf5)

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:792: InterfaceError</failure></testcase><testcase classname="tests.test_buy_merch" name="test_buy_merch" time="0.004"><failure message="sqlalchemy.exc.InterfaceError: (sqlalchemy.dialects.postgresql.asyncpg.InterfaceError) &lt;class 'asyncpg.exceptions._base.InterfaceError'&gt;: cannot perform operation: another operation is in progress&#10;[SQL: SELECT users.username, users.password, users.balance, users.id &#10;FROM users &#10;WHERE users.username = $1::VARCHAR]&#10;[parameters: ('testuser',)]&#10;(Background on this error at: https://sqlalche.me/e/20/rvf5)">self = &lt;AdaptedConnection &lt;asyncpg.connection.Connection object at 0xffff8a4353f0&gt;&gt;

    async def _start_transaction(self):
        if self.isolation_level == "autocommit":
            return
    
        try:
            self._transaction = self._connection.transaction(
                isolation=self.isolation_level,
                readonly=self.readonly,
                deferrable=self.deferrable,
            )
&gt;           await self._transaction.start()

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:843: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/asyncpg/transaction.py:146: in start
    await self._connection.execute(query)
/usr/local/lib/python3.11/site-packages/asyncpg/connection.py:349: in execute
    result = await self._protocol.query(query, timeout)
asyncpg/protocol/protocol.pyx:360: in query
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   asyncpg.exceptions._base.InterfaceError: cannot perform operation: another operation is in progress

asyncpg/protocol/protocol.pyx:745: InterfaceError

The above exception was the direct cause of the following exception:

self = &lt;sqlalchemy.engine.base.Connection object at 0xffff7b8ce310&gt;
dialect = &lt;sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0xffff8b0b0750&gt;
context = &lt;sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0xffff7b8ce550&gt;
statement = &lt;sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0xffff8a49a550&gt;
parameters = [('testuser',)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -&gt; CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
&gt;                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/default.py:942: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:580: in execute
    self._adapt_connection.await_(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:515: in _prepare_and_execute
    await adapt_connection._start_transaction()
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:845: in _start_transaction
    self._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;AdaptedConnection &lt;asyncpg.connection.Connection object at 0xffff8a4353f0&gt;&gt;
error = InterfaceError('cannot perform operation: another operation is in progress')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
&gt;                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.InterfaceError: &lt;class 'asyncpg.exceptions._base.InterfaceError'&gt;: cannot perform operation: another operation is in progress

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:792: InterfaceError

The above exception was the direct cause of the following exception:

    @pytest.mark.asyncio
    async def test_buy_merch():
        # Создаём транспорт для ASGI-приложения
        transport = ASGITransport(app=app)
        async with AsyncClient(transport=transport, base_url="http://test") as client:
            # 1. Регистрируем нового пользователя или логинимся
&gt;           auth_response = await client.post("/api/auth", json={"username": "testuser", "password": "testpass"})

tests/test_buy_merch.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/httpx/_client.py:1859: in post
    return await self.request(
/usr/local/lib/python3.11/site-packages/httpx/_client.py:1540: in request
    return await self.send(request, auth=auth, follow_redirects=follow_redirects)
/usr/local/lib/python3.11/site-packages/httpx/_client.py:1629: in send
    response = await self._send_handling_auth(
/usr/local/lib/python3.11/site-packages/httpx/_client.py:1657: in _send_handling_auth
    response = await self._send_handling_redirects(
/usr/local/lib/python3.11/site-packages/httpx/_client.py:1694: in _send_handling_redirects
    response = await self._send_single_request(request)
/usr/local/lib/python3.11/site-packages/httpx/_client.py:1730: in _send_single_request
    response = await transport.handle_async_request(request)
/usr/local/lib/python3.11/site-packages/httpx/_transports/asgi.py:170: in handle_async_request
    await self.app(scope, receive, send)
/usr/local/lib/python3.11/site-packages/fastapi/applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/middleware/errors.py:187: in __call__
    raise exc
/usr/local/lib/python3.11/site-packages/starlette/middleware/errors.py:165: in __call__
    await self.app(scope, receive, _send)
/usr/local/lib/python3.11/site-packages/starlette/middleware/exceptions.py:62: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
/usr/local/lib/python3.11/site-packages/starlette/routing.py:715: in __call__
    await self.middleware_stack(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/routing.py:735: in app
    await route.handle(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/routing.py:288: in handle
    await self.app(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/routing.py:76: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
/usr/local/lib/python3.11/site-packages/starlette/routing.py:73: in app
    response = await f(request)
/usr/local/lib/python3.11/site-packages/fastapi/routing.py:301: in app
    raw_response = await run_endpoint_function(
/usr/local/lib/python3.11/site-packages/fastapi/routing.py:212: in run_endpoint_function
    return await dependant.call(**values)
api/api_v1/users.py:39: in auth
    result = await db.execute(select(User).where(User.username == username))
/usr/local/lib/python3.11/site-packages/sqlalchemy/ext/asyncio/session.py:463: in execute
    result = await greenlet_spawn(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2365: in execute
    return self._execute_internal(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2251: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/default.py:942: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:580: in execute
    self._adapt_connection.await_(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:515: in _prepare_and_execute
    await adapt_connection._start_transaction()
/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:845: in _start_transaction
    self._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;AdaptedConnection &lt;asyncpg.connection.Connection object at 0xffff8a4353f0&gt;&gt;
error = InterfaceError('cannot perform operation: another operation is in progress')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
&gt;                   raise translated_error from error
E                   sqlalchemy.exc.InterfaceError: (sqlalchemy.dialects.postgresql.asyncpg.InterfaceError) &lt;class 'asyncpg.exceptions._base.InterfaceError'&gt;: cannot perform operation: another operation is in progress
E                   [SQL: SELECT users.username, users.password, users.balance, users.id 
E                   FROM users 
E                   WHERE users.username = $1::VARCHAR]
E                   [parameters: ('testuser',)]
E                   (Background on this error at: https://sqlalche.me/e/20/rvf5)

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:792: InterfaceError</failure></testcase></testsuite></testsuites>